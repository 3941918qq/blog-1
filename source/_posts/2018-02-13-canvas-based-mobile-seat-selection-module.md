---
layout: post
author: 碎碎酱
title: 基于canvas的移动端选座组件开发踩坑记
permalink: canvas-based-mobile-seat-selection-module
date: 2018-02-13
thumbnail: /img/javascript-logo.png
category: javascript
tags:
- javascript
lede: 
---

## 确认需求

选座组件需要具备如下功能:

1. 渲染场馆分区, 渲染区域座位
2. 座位可点击, 可显示为高亮和非高亮
3. 区域可拖动和缩放展示更多座位
4. 显示鹰眼图(区域缩略图), 鹰眼图座位状态与区域内座位状态保持一致(可售状态, 选中状态), 鹰眼图红框位置与用户可视区域保持一致
5. 显示行号, 行号状态与用户拖动/缩放操作保持一致

性能要求:

1. 支持10万座位的极端情况
2. 绘制时间低于1秒

移动端设备繁多, 性能和兼容性良莠不齐, 这是一个很大的考验.

> 关于移动端性能, 在不同设备执行相同的绘制任务, 设备包括mac pro, iPhone7, 红米note4x, 耗时比约为1:3:12  

## 技术选型

可选的技术方案包括: svg, canvas, webgl

svg是使用xml语言描述的矢量图形, 优点是兼容性好, 缩放操作不失真. 由于每一个svg图形都是一个dom节点, 而dom的性能一向都是极差的. 当座位数量过千时, 由于创建的dom节点过多, 不仅性能下降的厉害, 而且内存消耗也较为严重.

webgl是一种在网页中绘制3D图形的JavaScript API, 它使用GPU绘制, 并且辅有硬件加速能力, 性能较优. 不过webgl在移动端的兼容性较差, iOS需要在8以上, Android需要在5以上, 另外国内浏览器通常内核版本较低.

最终选定了canvas, canvas是HTML5标准的一部分, 它就像一张"画布", 提供了一套JavaScript API供我们在"画布"上绘制2D图形. 它支持iOS 3以及Android 3, 符合我们的期望

## 框架选型

技术方案敲定了canvas, 接下来考虑是否使用canvas绘图框架. 可选方案包括: 原生canvas, zrender, two.js, paper.js

综合考虑后, 在"这时"选择了使用zrender. zrender是托管在github上MIT协议的开源库, 它是Echarts图标库的底层绘图框架. 它有着优秀的文档, 使用OOP思想封装绘图操作, 避免操作枯燥的绘图API, 使得图形如同dom节点一般操作, 并且它还封装了事件模型, 动画操作等实用内容. 在开箱性能上, 它是优于其它方案的. 综合考虑觉得zrender最符合需求

> 在"这时"选择了使用zrender, 但是在后面的实践中, 我意识到这是一个错误的决定

## 绘制逻辑

我们的目标是支持10万座位, 一次性将10万个座位绘制出来是不现实的, 这样会使得用户消耗大量的时间等到绘制完成

可以在一开始时只绘制一部分座位, 等用户拖动视口到其他位置时, 再绘制视口内的座位

基于该策略, 对绘制逻辑分层, 并定义下面几个类:

* Seat: 座位类, 保存座位选中态, 高亮态, 座位接口数据. 提供座位绘制, 座位鹰眼图绘制, 选中, 反选中, 高亮, 反高亮等方法
* Area: 区域类, 保存所有座位(以行/列为key的二阶Map), 座位票价组, 座位套票组. 提供添加座位, 绘制座位, 绘制鹰眼图, 获取座位大小, 获取区域大小等方法
* Viewport: 视口类, 保存视口位置, 大小, 缩放倍率. 提供移动视口, 缩放视口, 获取视口偏移量, 获取视口缩放率等方法
* Thumbnail: 鹰眼图类, 提供绘制, 更新, 显示, 隐藏鹰眼图等功能
* Render: 绘制类, 负责初始化环境, 处理座位数据, 绘制选座视图

初始绘制流程如下:

0. 初始化Render, 包括创建dom节点, 初始化绘图context, 初始化Area/Viewport/Thumbnail
0. 遍历座位数据, 将座位添加到Area
0. 获取视口位置和座位大小, 计算出现在视口中的座位起始行列号和终止行列号
0. 遍历Area在该行列范围内的座位, 调用draw方法绘制出来, 订阅座位click事件
0. 绘制鹰眼图, 调用Area.drawAll绘制所有座位缩略图, 根据视口位置绘制红框
0. 绘制行号, 根据视口偏移量计算行号div偏移量, 根据座位高度和视口缩放倍率, 调整单行高度
0. 监听canvas手势事件

当点击座位时:

0. 修改响应的座位实例属性
0. zrender自动重绘座位

当触发手势拖动/缩放操作时:

0. 根据点坐标计算移动距离/缩放倍率
0. 更新视口位置/缩放倍率
0. 清空绘图context
0. 计算当前视口下, 出现在视口中的座位起始行列号和终止行列号
0. 更新这些座位属性并绘制

## 性能问题

使用上述的绘制逻辑, 绘制初始绘制仅渲染用户看的座位, 解决了初始绘制时间问题

但是在移动端设备上, 在用户拖动或者缩放时, 会感觉十分的不流畅, 在低端机型上感受尤为明显, 会感觉"拖不动"

分析拖动过程, 每次用户拖动时, 都会消耗大量的CPU时间用于计算视口内座位, 调整视口属性, 清空画布重绘. 

而实际上, 如果用户向右拖动50px, 仅需绘制这多出来的50px内容, 原有内容已经绘制过了, 左移50px即可

## 第一次优化尝试

首先想到的就是如何减少拖动过程中的CPU计算消耗, 观察一些web地图, 发现它们在拖动的过程中都不会发生绘制, 而是等拖动停止后再开始绘制

对上述的绘制逻辑做些简单的修改, 在拖动时直接移动canvas节点位置, 拖动停止后再重绘座位, 并将canvas节点移回到初始位置

这使得拖动性能有了极大的提升, 但是用户会看的较长的白屏时间. 那如果提前把用户要滑到的位置绘制出来呢? 我们考虑将上下左右各多绘制75%视口宽度/高度的内容, 即绘制2.5倍视口大小, 稍微增加一次绘制的时间, 但是拖动时不会再显示出大片的白屏

经过优化后, 每次拖动操作仅在结束时重绘一次. 在移动端实际体验时, 又遇到了几个问题: 

1. 一是拖动结束后, 在重绘座位和将canvas位置复原时, 用户偶尔会有跳动的感觉; 
2. 二是当用户连续快速拖动时, 上一次绘制任务还没结束就触发了下一次绘制, 用户又一次有了"卡顿"感
3. 三是缩放操作仍要不断的重绘, 性能差

## 第二次优化尝试

针对遇到的问题, 我们开始从根源上考虑解决办法. 实际上对于选座应用来说, 座位状态改变是个低频操作, 所以不应该有频繁的重绘.

如果我们创建一张完整大小的画布, 初始还是绘制视口内的座位, 随着视口移动, 逐步填充这块画布空白的部分. 对于拖动/缩放操作, 将画布当成图片一样使用CSS高效的将其移动/缩放. 每个座位仅被绘制一次, 座位状态改变时, 不清空画布, 直接在座位原位置绘制新的座位

前面提到选择zrender是一个错误的决定, 因为使用CSS对canvas缩放会影响zrender的事件系统; zrender对绘制进行了封装, 使得没法控制每一步绘制过程; 并且仅仅使用了zrender有限的功能, 但是却使得库打包体积增大了很多. 于是开始去掉zrender, 得益于一开始对绘制过程的分层与封装, 在更换zrender的过程中并没有遇到太大的困难

重构完成后, 拖动与缩放操作如丝滑般流畅

## 总结

该文记录了从定方案到不断采坑优化再到最后交付的过程, 感悟颇多:

* 多思考, 多实践, 慢点下决定
* 多采集数据, 根据数据得出结论, 定位问题
* 从根本考虑问题, 从根源解决问题