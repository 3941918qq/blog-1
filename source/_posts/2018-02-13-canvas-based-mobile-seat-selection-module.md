---
layout: post
author: 碎碎酱
title: 移动端选座开发 - 技术选型&性能优化之路
permalink: canvas-based-mobile-seat-selection-module
date: 2018-02-13
thumbnail: /img/javascript-logo.png
category: javascript
tags:
- javascript
lede: 移动端设备繁多, 性能良莠不齐, 在这种场景下如何解决巨量座位绘制呢
---

## 明确选座需求

#### 选座组件需要具备如下功能:

1. 渲染场馆底图以及各个区域, 渲染区域内座位
2. 区域点击后跳转到该区域选择座位页, 座位会显示为正常、已售、锁定、选中、半透明等多种状态, 点击座位后切换状态
3. 支持手势拖动和缩放, 支持高亮指定票价的座位
4. 支持鹰眼图(区域缩略图), 鹰眼图座位状态与区域内座位状态保持一致(可售状态, 选中状态), 鹰眼图红框位置与用户可视区域保持一致
5. 显示行号, 行号状态与用户拖动/缩放操作保持一致

#### 性能要求:

支持10万座位的极端情况
绘制时间低于1秒, 从打开页面到用户可操作时间低于2秒

由于移动端设备繁多, 性能和兼容性良莠不齐, 这是一个很大的考验.

>  简易度量移动端性能, 尝试在不同设备执行相同的绘制任务, 设备包括mac pro, iPhone7, 红米note4x, 耗时比约为1:3:12

## 选择绘图方案

#### 可选的绘图方案包括: svg, canvas, webgl

svg是使用xml语言描述的矢量图形, 优点是兼容性好, 缩放操作不失真. 由于每一个svg图形都是一个dom节点, 而dom的性能一向都是极差的. 当座位数量过千时, 由于创建的dom节点过多, 不仅性能下降的厉害, 而且内存消耗也较为严重

webgl是一种在网页中绘制3D图形的JavaScript API, 它使用GPU绘制, 并且辅有硬件加速能力, 性能较优. 不过webgl在移动端的兼容性较差, iOS需要在8以上, Android需要在5以上, 另外国内浏览器通常内核版本较低

canvas是HTML5标准的一部分, 它就像一张"画布", 提供了一套JavaScript API供我在"画布"上绘制2D图形. 它支持iOS 3以及Android 3, 符合我的期望, 因此我选择canvas作为底层绘图方案

## 选择canvas绘图库

绘图方案敲定了canvas, 接下来考虑是使用canvas原生API还是使用成熟的绘图库. 可选方案包括: 原生canvas, zrender, two.js, paper.js

综合考虑后, 我选择了使用zrender. zrender是托管在github上MIT协议的开源库, 它是Echarts图标库的底层绘图框架. 它有着优秀的文档, 使用OOP思想封装绘图操作, 避免操作枯燥的绘图API, 使得图形如同dom节点一般操作, 并且它还封装了事件模型, 动画操作等实用内容. 在开箱性能上, 它是优于其它方案的. 综合考虑后zrender最符合需求

>  我在这时通过简单的对比各方案, 冒昧的选择了使用zrender, 但是在后面的实践中, 意识到这是一个错误的决定

## 制定绘制策略

我的目标是支持10万座位, 一次性将10万个座位绘制出来是不现实的, 这样会使得用户消耗大量的时间等到绘制完成
因为整个场馆是很大的, 而用户视口大小却是有限的, 可以只绘制用户视口内的这一部分座位, 等用户拖动视口到其他位置时, 清空画板, 再重新绘制视口内的座位

#### 基于该策略, 对绘制逻辑分层, 并定义下面几个类:

* Seat: 座位类, 保存座位选中态, 高亮态, 座位接口数据. 提供座位绘制, 座位鹰眼图绘制, 选中, 反选中, 高亮, 反高亮等方法
* Area: 区域类, 保存所有座位(以行/列为key的二阶Map), 座位票价组, 座位套票组. 提供添加座位, 绘制座位, 绘制鹰眼图, 获取座位大小, 获取区域大小等方法
* Viewport: 视口类, 保存视口位置, 大小, 缩放倍率. 提供移动视口, 缩放视口, 获取视口偏移量, 获取视口缩放率等方法
* Thumbnail: 鹰眼图类, 提供绘制, 更新, 显示, 隐藏鹰眼图等功能
* Render: 绘制类, 负责初始化环境, 处理座位数据, 绘制选座视图

#### 初始绘制流程如下:

1. 初始化Render, 包括创建dom节点, 初始化绘图context, 初始化Area/Viewport/Thumbnail
2. 遍历座位数据, 将座位添加到Area
3. 获取视口位置和座位大小, 计算出现在视口中的座位起始行列号和终止行列号
4. 遍历Area在该行列范围内的座位, 调用draw方法绘制出来, 订阅座位click事件
5. 绘制鹰眼图, 调用Area.drawAll绘制所有座位缩略图, 根据视口位置绘制红框
6. 绘制行号, 根据视口偏移量计算行号div偏移量, 根据座位高度和视口缩放倍率, 调整单行高度
7. 监听canvas手势事件

#### 当点击座位时:

1. 修改响应的座位实例属性
2. zrender自动重绘座位

#### 当触发手势拖动/缩放操作时:

1. 根据点坐标计算移动距离/缩放倍率
2. 更新视口位置/缩放倍率
3. 清空绘图context
4. 计算当前视口下, 出现在视口中的座位起始行列号和终止行列号
5. 更新这些座位属性并绘制

## 性能问题

使用上述的绘制逻辑, 绘制初始绘制仅渲染用户看的座位, 解决了初始绘制时间问题
但是在移动端设备上, 在用户拖动或者缩放时, 会感觉十分的不流畅, 在低端机型上感受尤为明显, 会感觉"拖不动"

#### 下面是在iPhone7真机运行视频:

<video style="width: 375px;height: 667px;margin: 0 auto" src="https://lark.alipay.com/attachments/2018/mp4/17cbde4d-9903-492f-8eb3-a50d45a08398.mp4" controls="" preload="true" autoplay="true"></video>

#### 使用Chrome Devtool分析页面性能消耗, 入下图所示:

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4a5411f4f933521ad8d54ed69ce9fc80.png)

可以发现, 每一次用户拖动时CPU都会飙升到顶点, 平均fps值在22左右, 58.4%的时间消耗在了JavaScript运行上, GPU绘制时间仅仅占7.9%

分析拖动过程, 每次用户拖动时, 都会消耗大量的CPU时间用于计算视口内座位, 调整视口属性, 清空画布重绘.
而实际上, 如果用户向右拖动50px, 实际上仅需绘制这多出来的50px内容, 原有内容已经绘制过了是没有变化的, 将其左移50px即可

## 第一次优化尝试

首先想到的就是如何减少拖动过程中的CPU计算消耗, 观察现有的web地图应用, 发现它们在拖动的过程中都不会发生绘制, 而是等拖动停止后再开始绘制

对上述的绘制逻辑做些简单的改造, 在拖动时直接移动canvas节点位置, 拖动停止后再重绘座位, 并将canvas节点移回到初始位置

这使得拖动性能有了极大的提升, 但是用户会看的较长的白屏时间. 那如果提前把用户要滑到的位置绘制出来呢? 我考虑将上下左右各多绘制75%视口宽度/高度的内容, 即绘制2.5倍视口大小, 稍微增加一次绘制的时间, 但是拖动时不会再显示出大片的白屏

#### 优化后在iPhone7上运行效果如下:

<video style="width: 375px;height: 667px;margin: 0 auto" src="https://lark.alipay.com/attachments/2018/mp4/dc149f6a-1a00-4a34-9460-3c2c6a8f9fed.mp4" controls="" preload="true" autoplay="true"></video>

经过优化后, 每次拖动操作仅在结束时重绘一次. 在移动端实际体验时, 又遇到了几个问题:

一是拖动结束后, 在重绘座位和将canvas位置复原时, 用户偶尔会有跳动的感觉;
二是当用户连续快速拖动时, 上一次绘制任务还没结束就触发了下一次绘制, 用户又一次有了"卡顿"感
三是缩放操作仍要不断的重绘, 性能差

#### Chrome性能分析结果如下图:

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a347b1ad343fdb8ea6c8a88357001412.png)


可以看到, 在持续的拖动时我有效的降低的JavaScript执行时间, 但是拖动结束后仍需一次完整绘制, 导致CPU爆满, 因为当用户连续的小间隔拖动时, 仍会会连续的消耗CPU性能

## 第二次优化尝试

针对遇到的问题, 我开始从根源上考虑解决办法. 实际上对于选座应用来说, 座位状态改变是个低频操作, 所以不应该有频繁的重绘.

如果我创建一张完整大小的画布, 初始还是绘制视口内的座位, 随着视口移动, 逐步填充这块画布空白的部分. 对于拖动/缩放操作, 将画布当成图片一样使用CSS高效的将其移动/缩放. 每个座位仅被绘制一次, 座位状态改变时, 不清空画布, 直接在座位原位置绘制新的座位

前面提到当时选择zrender是一个错误的决定, 因为在zrender中使用CSS对canvas缩放会影响zrender的事件系统; zrender对绘制进行了封装, 使得没法控制每一步绘制过程; 并且我仅仅用到了zrender部分功能, 但是却使得组件打包体积增大了很多. 于是我开始尝试去掉zrender, 得益于一开始对绘制过程的分层与封装, 在把zrender替换为元生API的过程中并没有遇到太大的困难, 完美完成飞机空中换引擎的挑战

#### 重构后在iPhone7上运行效果如下:

<video style="width: 375px;height: 667px;margin: 0 auto" src="https://lark.alipay.com/attachments/2018/mp4/6b1f3191-8b65-44dd-9757-8f55e5e891d6.mp4" controls="" preload="true" autoplay="true"></video>

#### Chrome性能分析图:

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/012d7d620636b69fab724302b7df3267.png)

我将CPU时间缩减到7.2%, 而且不再出现拖动后CPU爆满的情况
重构完成后, 拖动与缩放操作如丝滑般流畅

##总结

移动端选座从定方案到不断采坑优化再到最后交付的过程, 感悟颇多:

* 定方案前多思考,多实践, 慢点下决定
* 多采集数据, 根据数据定位问题, 制定有效的解决方案
* 从根本考虑问题, 从根源解决问题